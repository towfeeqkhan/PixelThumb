import { GenerateContentConfig } from "@google/genai";
import { v2 as cloudinary } from "cloudinary";
import { Request, Response } from "express";
import fs from "fs";
import path from "path";
import ai from "../config/ai.js";
import Thumbnail from "../models/thumbnail.model.js";

const stylePrompts = {
  "Bold & Graphic":
    "eye-catching thumbnail, bold typography, vibrant colors, expressive facial reaction, dramatic lighting, high contrast, click-worthy composition, professional style",
  "Tech/Futuristic":
    "futuristic thumbnail, sleek modern design, digital UI elements, glowing accents, holographic effects, cyber-tech aesthetic, sharp lighting, high-tech atmosphere",
  Minimalist:
    "minimalist thumbnail, clean layout, simple shapes, limited color palette, plenty of negative space, modern flat design, clear focal point",
  Photorealistic:
    "photorealistic thumbnail, ultra-realistic lighting, natural skin tones, candid moment, DSLR-style photography, lifestyle realism, shallow depth of field",
  Illustrated:
    "illustrated thumbnail, custom digital illustration, stylized characters, bold outlines, vibrant colors, creative cartoon or vector art style",
};

const colorSchemeDescriptions = {
  vibrant:
    "vibrant and energetic colors, high saturation, bold contrasts, eye-catching palette",
  sunset:
    "warm sunset tones, orange pink and purple hues, soft gradients, cinematic glow",
  forest:
    "natural green tones, earthy colors, calm and organic palette, fresh atmosphere",
  neon: "neon glow effects, electric blues and pinks, cyberpunk lighting, high contrast glow",
  purple:
    "purple-dominant color palette, magenta and violet tones, modern and stylish mood",
  monochrome:
    "black and white color scheme, high contrast, dramatic lighting, timeless aesthetic",
  ocean:
    "cool blue and teal tones, aquatic color palette, fresh and clean atmosphere",
  pastel:
    "soft pastel colors, low saturation, gentle tones, calm and friendly aesthetic",
};

export const generateThumbnail = async (req: Request, res: Response) => {
  let thumbnail: any = null;

  try {
    const { userId } = req.session;
    const {
      title,
      user_prompt,
      style,
      aspect_ratio,
      color_scheme,
      text_overlay,
    } = req.body;

    // 1. Create DB entry
    thumbnail = await Thumbnail.create({
      userId,
      title,
      prompt_used: user_prompt,
      user_prompt,
      style,
      aspect_ratio,
      color_scheme,
      text_overlay,
      isGenerating: true,
    });

    // 2. Model config
    const model = "gemini-3-pro-image-preview";

    const generationConfig: GenerateContentConfig = {
      maxOutputTokens: 8192,
      temperature: 1,
      topP: 0.95,
      responseModalities: ["IMAGE"],
      imageConfig: {
        aspectRatio: aspect_ratio || "16:9",
        imageSize: "1K",
      },
    };

    // 3. Prompt building
    const selectedStyle =
      stylePrompts[style as keyof typeof stylePrompts] ||
      stylePrompts["Bold & Graphic"];

    const selectedColor =
      colorSchemeDescriptions[
        color_scheme as keyof typeof colorSchemeDescriptions
      ] || "";

    let prompt = `Create a ${selectedStyle} for a video titled: ${title}.`;

    if (selectedColor) {
      prompt += ` Use a ${selectedColor} color scheme.`;
    }

    if (user_prompt) {
      prompt += ` Additional details: ${user_prompt}.`;
    }

    prompt += ` The thumbnail should be ${
      aspect_ratio || "16:9"
    }, visually striking, professional, and high-resolution.`;

    // Save the final prompt
    thumbnail.prompt_used = prompt;
    await thumbnail.save();

    // 4. Generate image
    const response: any = await ai.models.generateContent({
      model,
      contents: [{ role: "user", parts: [{ text: prompt }] }],
      config: generationConfig,
    });

    const parts = response?.candidates?.[0]?.content?.parts;
    if (!parts || parts.length === 0) {
      throw new Error("No image generated by the model.");
    }

    let finalBuffer: Buffer | null = null;

    for (const part of parts) {
      if (part.inlineData?.data) {
        finalBuffer = Buffer.from(part.inlineData.data, "base64");
        break;
      }
    }

    if (!finalBuffer) {
      throw new Error("Response contained no inline image data.");
    }

    // 5. Save locally
    const filename = `thumbnail-${Date.now()}-${userId}.png`;
    const imagesDir = path.join(process.cwd(), "images");
    const filePath = path.join(imagesDir, filename);

    if (!fs.existsSync(imagesDir)) {
      fs.mkdirSync(imagesDir, { recursive: true });
    }

    fs.writeFileSync(filePath, finalBuffer);

    // 6. Upload to Cloudinary
    const publicId = `PixelThumb-Generated-thumbnail-${Date.now()}`;

    const uploadResult = await cloudinary.uploader.upload(filePath, {
      resource_type: "image",
      folder: "thumbnails",
      public_id: publicId,
      overwrite: false,
    });

    // 7. Update DB (SUCCESS)
    thumbnail.image_url = uploadResult.secure_url;
    thumbnail.isGenerating = false;
    await thumbnail.save();

    // 8. Cleanup
    fs.unlinkSync(filePath);

    res.status(200).json({
      message: "Thumbnail generated successfully",
      thumbnail,
    });
  } catch (error: any) {
    console.error("Error generating thumbnail:", error);

    // cleanup DB state on failure
    if (thumbnail?._id) {
      await Thumbnail.updateOne(
        { _id: thumbnail._id },
        { isGenerating: false },
      );
    }

    res.status(500).json({
      message: "Failed to generate thumbnail",
      error: error.message,
    });
  }
};

export const deleteThumbnail = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { userId } = req.session;

    await Thumbnail.findOneAndDelete({ _id: id, userId });

    res.status(200).json({
      message: "Thumbnail deleted successfully",
    });
  } catch (error: any) {
    console.error("Error deleting thumbnail:", error);
    res.status(500).json({
      message: "Failed to delete thumbnail",
      error: error.message,
    });
  }
};
